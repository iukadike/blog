---
layout: post
title: MD5 Collision Attack
excerpt: MD5 is a type of one-way hash function. A one-way hash function is a cryptographic function that takes an input and generates a fixed-size output. When a one-way hash function produces the same hash output for different inputs, this is known as a collision. A good one-way hash function must be collision-resistant. The collision-resistance property ensures that it is computationally infeasible to find two inputs that produce the same hash output. If a hash function lacks collision resistance, it becomes vulnerable to collision attacks such as birthday attacks, where an attacker tries to find two inputs that produce the same hash value.
categories: [crypto, md5]
---

MD5 is a type of one-way hash function.

A one-way hash function is a cryptographic function that takes an input and generates a fixed-size output. There are several properties of a one-way hash function. Some of these include:

- getting the original input from the hash value must be computationally infeasible.

- changing a single character in the input should result in a completely different hash value.

- it should have a negligible probability of producing the same hash output for different inputs

When a one-way hash function produces the same hash output for different inputs, this is known as a collision. A good one-way hash function must be collision-resistant. The collision-resistance property ensures that it is computationally infeasible to find two inputs that produce the same hash output. If a hash function lacks collision resistance, it becomes vulnerable to collision attacks such as birthday attacks, where an attacker tries to find two inputs that produce the same hash value.

Collision attacks can be achieved through various techniques, such as brute force searching, exploiting weaknesses or vulnerabilities in the hash function, or using advanced mathematical algorithms.

One-way hash functions are used in password storage, data verification, digital signatures, and data integrity checks.

<details>
<summary><b>SeedLabs: MD5 Collision Attack Lab</b></summary>
<div markdown="1">

- [MD5 Collision Attack Lab](https://seedsecuritylabs.org/Labs_20.04/Files/Crypto_MD5_Collision/Crypto_MD5_Collision.pdf)

___
</div></details>


### Generating Two Different Files with the Same MD5 Hash

This lab section deals with generating two different files with the same MD5 hash values. To achieve this, the beginning parts of both files need to be the same; which means they have to share the same prefix. A prefix refers to a specific set of bytes that are added to the beginning of data before it is hashed.

The `md5collgen` program allows us to provide a prefix file with any arbitrary content.

```python
#!/usr/bin/env python3

with open("prefix.txt", "w") as file:
    file.write("A" * 64)
```

```bash
$ md5collgen -p prefix.txt -o out1.bin out2.bin
```

![task-1-a](https://github.com/iukadike/blog/assets/58455326/25640f87-5af4-4ad0-8512-b85c29b13092)

When I check whether the out1.bin and out2.bin files are distinct using the diff command, the result is that out1.bin and out2.bin differ.

![task-1-b](https://github.com/iukadike/blog/assets/58455326/28f990a3-1988-475b-9f62-4f64d6a3cdf4)

However, when I use the md5sum command to check the MD5 hash of out1.bin and out2.bin, the result is that the hash values of out1.bin and out2.bin are the same.

![task-1-c](https://github.com/iukadike/blog/assets/58455326/361ca450-c1b8-484a-9d0f-0eb82437481d)

Since the output of md5collgen: out1.bin and out2.bin are binary files, we need to use a hex editor to view and edit them. When I view the binary files with a hex editor, I can see the characters I supplied in the prefix file.

Inspecting the binary files, I noticed the following:

- if the length of your prefix file is not a multiple of 64, md5collgen makes up for the length by filling the block with zeros.

![task-1-d](https://github.com/iukadike/blog/assets/58455326/e4eccd1b-45c8-447c-968a-3b930bcf62c8)

- whereas if the prefix file is exactly 64 bytes, there is no zero padding.

![task-1-e](https://github.com/iukadike/blog/assets/58455326/05ae8f3e-4787-48e0-aea1-473d17496817)

- the data generated by md5collgen is not completely different for the out1.bin and out2.bin output files?


<br>

### Understanding MD5â€™s Property

This lab section deals with trying to understand some of the properties of the MD5 algorithm. These properties include:
- MD5 divides the input data into blocks of 64 bytes
- it then computes the hash iteratively on these blocks via a compression function. This compression function takes a 64-byte data block and the outcome of the previous iteration as input.
- the output of the compression function is a 128-bit Intermediate Hash Value (IHV).
- the IHV for the first iteration is a fixed predetermined value
- the IHV for the last iteration becomes the final hash value of the data.

Based on the above, given two inputs M and N, if `MD5(M) = MD5(N)`, then for any input T, `MD5(M || T) = MD5(N || T)`, where `||` represents concatenation.

What this simply means is that if inputs M and N have the same hash, should I add the same suffix T to them, their outputs will have the same hash value. To demonstrate this, I will concatenate the `ls` binary to out1.bin and out2.bin respectively, and calculate the hash value of their outputs.

```bash
cat out1.bin /usr/bin/ls > out3.bin
cat out2.bin /usr/bin/ls > out4.bin
md5sum out3.bin out4.bin
```

from the results in the screenshot below, we can see that the outputs produce the same hash value.

![task-2-a](https://github.com/iukadike/blog/assets/58455326/191b22ce-09a8-4dca-bfe6-a720294fd090)

<br>

###  Generating Two Executable Files with the Same MD5 Hash

This lab section deals with creating two different versions of a program given below, such that the contents of their "xyz" arrays are different, but the hash values of the executables are the same.

```c
#include <stdio.h>

unsigned char xyz[200] = {
  /* The actual contents of this array are up to you */
};

int main()
{
  int i;
  for (i=0; i<200; i++){
    printf("%x", xyz[i]);
  }
  printf("\n");
}
```

I can go about this in two ways:
- working at the source code level, i.e., generating two versions of the above C program, such that after compilation, their corresponding executable files have the same MD5 hash value.
- working at the binary level, i.e., putting some arbitrary values in the "xyz" array, compiling the code to binary, and using a hex editor tool to modify the content of the "xyz" array.

In order to find where the contents of the array are stored in the binary, I fill the array with "A"s (0x41) so I can easily find them in the binary. I write a Python program that will generate 200 'A's formatted for easy copy to the c code.

```python
#!/usr/bin/env python3

#array = input("Type in the characters you want to transform: ")
array = "A" * 200

result = bytes.hex(array.encode())
a = 0; b = 0

for _ in result[::2]:
    print (f"0x{result[a:a+2]}, ", end="")
    a += 2
    b += 1
    # Make each output 10 characters per line
    if b % 10 == 0:
        print()    
print()
```

When I compile the c code and inspect the binary in a hex editor, I am able to identify the array.

![task-3-a](https://github.com/iukadike/blog/assets/58455326/37a2fb89-83c5-4269-8cc4-fa5bff830ebc)

From inside the array, I can divide the executable file into three parts:
- a prefix (The length of the prefix needs to be multiple 0f 64 bytes)
- a 128-byte region
- a suffix. 

the array starts from 12320 to 12519. since the array has to be a part of the prefix, I need to look for a number within the array that is a multiple of 64. I ended up with 12352.

```bash
$ head -c 12352 md5col > prefix
```

the 128-byte region will be generated by md5collgen

```bash
$ md5collgen -p prefix -o out1.bin out2.bin
```

the suffix will start from 12352 + 128 = 12480.

```bash
$ tail -c +12481 md5col > suffix
```

finally, I added the suffix to out1.bin and out2.bin

```bash
$ cat suffix >> out1.bin
$ cat suffix >> out2.bin
```

When I check the hash values of out1.bin and out2.bin, the values are the same. However, when I check out1.bin and out2.bin with the diff utility, the programs differ.

![task-3-b](https://github.com/iukadike/blog/assets/58455326/19d820d3-030e-481b-bcba-352ff7984e82)


<br>

###  Making the Two Programs Behave Differently

This lab section deals with creating two independent programs that perform different functions but share the same hash value.

If an attacker can get his malicious software to share the same hash as a benign software, a certificate that is valid for the benign software is also valid for the malicious program. Therefore, the attacker has successfully obtained a valid certificate for his malicious program. If other people trust the certificate issued by the authority, they will download the malicious program.

One approach is to create two arrays X and Y and compare the contents of these two arrays; if they are the same, the benign code is executed; otherwise, the malicious code is executed.

```c
#include <stdio.h>

unsigned char X[200] = {
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
};

unsigned char Y[200] = {
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
};

int compare()
{
    for(int i = 0; i < 200;i++){
        if (X[i] == Y[i]){
            continue;
        } else{
            return 1;
        }
    }
    return 0;
}


int main()
{
    if (compare() == 0){
        printf("Benign code executed..\n");
    } else{
        printf("Malicious code executed..\n");
    }
    printf("\n");
}
```

The image below illustrates what the two versions of the program will look like.

![image](https://github.com/iukadike/blog/assets/58455326/48e61674-d026-4082-9209-bb51a36e011c)

Due to the complexity of this task, I broke it down into a number of sub-tasks.

__1. Identifying the Prefix__

After compiling the program and opening it in a hex editor, I was able to determine that the prefix is 12352. The first array starts from 12320 to 12519. since the array has to be a part of the prefix, I need to look for a number within the array that is a multiple of 64.

![task-4-a](https://github.com/iukadike/blog/assets/58455326/17d25218-73c3-4366-a0c2-923e94f0fc22)

__2. Extracting the Prefix__

Next is to extract the prefix using the head utility

```bash
$ head -c 12352 md5col2 > prefix
```

__3. Generating Collision Data using md5collgen__

Next is to generate two different programs that will generate the same hash

```bash
$ md5collgen -p prefix -o out1 out2
```

__4. Extracting the 128 bytes Collision Data__

When md5collgen is run, it generates 128 bytes of data that is added to the prefix. This 128 bytes of data is responsible for the collision. The next step is to extract these 128 bytes of data and save them for post-processing. These 128 bytes of data are at the end of the file and can be extracted using the tail utility.

```bash
$ tail -c 128 out1 > P
$ tail -c 128 out2 > Q
```

__5. Make Two Copies of the Program__

```bash
$ cp md5col2 malicious_code
$ cp md5col2 benign_code
```

__6. Edit the Benign Program__

Because of the complexity of the program, the method of concatenation that was used in a previous task is not feasible. The binary will have to be edited in a hex editor. Another option though is to use the `dd` utility.

As predetermined:
- the first array starts at offset 12320; however, 12320 is not a multiple of 64, so I had to select 12352 which is a multiple of 64
- the difference between 12352 and 12320 is 32
- the second array starts at the offset 12544; however, since I am going to be comparing array X with array Y to determine the program flow of control, I need to ensure that where I will place the collision data in array X and array Y match
- I had to move the offset of array X by 32 to make up for the block size; this means I also have to move array Y by 32
- the sum of 12544 and 32 is 12576

```bash
$ dd if=P of=benign_code bs=1 count=128 seek=12352 conv=notrunc
$ dd if=P of=benign_code bs=1 count=128 seek=12576 conv=notrunc
```

The above code simply means: copy 128 bytes of data from the file "P" 1 byte at a time into the file "good_code" from the offset 12352 and 12576 respectively; do not truncate the output file.

![task-4-b](https://github.com/iukadike/blog/assets/58455326/639773d0-5006-4813-b3b0-2226f289fcd0)

__6. Edit the Malicious Program__

As with the above, the determined data is the same:

```bash
$ dd if=Q of=malicious_code bs=1 count=128 seek=12352 conv=notrunc
$ dd if=P of=malicious_code bs=1 count=128 seek=12576 conv=notrunc
```

![task-4-c](https://github.com/iukadike/blog/assets/58455326/935b0ef2-f25f-4eec-8b0c-d6559cebf274)

__7. Testing the Programs__

All that is left is to test the programs to see if it works as expected.

The first test is to see if benign_code and malicious_code produce the same hash value:

```bash
$ md5sum benign_code malicious_code
```

From the screenshot below, they indeed have the same hash value

![task-4-d](https://github.com/iukadike/blog/assets/58455326/45f9f48d-023b-4c19-8760-9ff67a08e8aa)

The second test is to see if they execute differently: From the screenshot below, they indeed do execute differently

![task-4-e](https://github.com/iukadike/blog/assets/58455326/54c086c6-9e05-44e4-94ed-b48ce169478f)


<br>

Thanks for reading...

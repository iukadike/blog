---
layout: post
title: RSA Public-Key Encryption and Signature
excerpt: Public key infrastructure is a system of cryptographic keys, digital certificates, and certificate authorities that is used to verify the authenticity of digital information and ensure secure communication over networks. A PKI system uses a public key and a private key. While the public key is freely available and used to encrypt data or verify digital signatures, the private key is kept secret and used for decryption or creating digital signatures.
categories: [crypto, rsa]
---

![Encryption]({{ site.baseurl }}/images/featured-images/rsa.jpg)



### Diffie-Hellman Key Exchange

Diffie-Hellman key exchange is a protocol that enables two parties who have no prior knowledge of each other to exchange secret keys over an insecure communication channel through the use of modular exponentiation. It was invented by Whitfield Diffie and Martin Hellman in 1976.

The Diffie-Hellman key works as follows:
- Both parties, i.e. Alice and Bob, agree on a large prime number, `p`, and a generator, `g`, a smaller prime number. The values of `p` and `g` are public and can be known by any attacker.
- Alice picks a private key `x` which is less than `p`. Bob also picks a private key `y` which is less than `p`. These private keys are kept secret.
- Alice computes `A = g^a mod p`, and Bob computes `B = g^b mod p`. These are the public keys that both parties then exchange openly.
- Alice and Bob use the received public keys and their private keys to compute the same shared secret key. Alice computes `s = B^a mod p`, while Bob computes `s = A^b mod p`.
- Alice and Bob now have the same shared secret key, `g^(ab) mod p`, which can be used for symmetric encryption, such as AES, to ensure confidential communication over an insecure channel.

The security of the Diffie-Hellman key exchange is based on the difficulty of the discrete logarithm problem, which is the problem of finding the exponent in modular exponentiation. If an attacker intercepts the exchanged public keys or messages, they would need to solve the discrete logarithm problem, which is computationally infeasible for large prime numbers.


### The RSA Algorithm

The RSA (Rivest-Shamir-Adleman) algorithm is named after its creators: Ron Rivest, Adi Shamir, and Leonard Adleman. The RSA algorithm is based on the mathematical properties of prime numbers and involves the use of a public key for encryption and a private key for decryption.

The RSA algorithm generates the private and public as follows:
- Choose two distinct large prime numbers, p and q.
- Compute n = p * q. This number becomes the modulus for the public key and private key.
- Compute the totient function, φ(n) = (p-1) * (q-1).
- Find a number e, where 1 < e < φ(n) and gcd(e, φ(n)) = 1 (This means that e is relatively prime to φ(n)). This becomes the public key exponent (e)
- Compute the private key exponent (d) as the modular multiplicative inverse of e modulo φ(n), i.e., d ≡ e^(-1) mod φ(n).

RSA encrypts data as follows:
- Convert the plaintext message into a numerical value using a suitable scheme (e.g., ASCII).
- Encrypt the numerical value using the public key: c = m^e mod n, where m is the numeric representation of the plaintext message and c is the ciphertext.

RSA decrypts data as follows:
- Decrypt the ciphertext using the private key: m = c^d mod n, where m is the decrypted numerical value and c is the ciphertext.
- Convert the numerical value back into the plaintext message using the same scheme as in the encryption step.

The security of the RSA algorithm relies on the factorization of large composite numbers. It is computationally difficult and time-consuming to factorize a large number into its prime factors, making the algorithm secure against attacks.

<details>
<summary><b>Note</b></summary>

___
When the private key is used for encryption, it no longer serves the purpose of encryption, because anyone with the public key has access to the encrypted data. Instead, when a private key is used, it is used as a form of signature to show that the data is from the expected origin.
</details>

In this post, I aim to document my findings and observations while performing a SEED lab.


<br>

### Deriving the Private Key

This section of the lab involves deriving a private key from the following:
- a public exponent (e): 0D88C3
- a large prime number (p): F7E75FDC469067FFDC4E847C51F452DF
- a large prime number (q): E85CED54AF57E53E092113E62F436F4F

<details>
<summary><b>Note</b></summary>
<div markdown="1">

___
- The prime numbers used for this lab are 128 bits and are not large enough to be secure. However, 128 bits were selected to simplify the lab.
- In practice, these numbers should be at least 512 bits long.
</div></details>

The numbers involved in the RSA algorithms are typically more than 512 bits long and as such we cannot simply do `a * b`, but need to use an algorithm to compute their products. This lab makes use of the Big Number library provided by OpenSSL.

Using this library is straightforward. We define each big number as a BIGNUM type:
- A structure created to hold BIGNUM temporary variables used by library functions: __BN_CTX *ctx = BN_CTX_new()__
- Initialize a BIGNUM variable: __BIGNUM *a = BN_new()__

And then use the APIs provided by the library for various operations, such as:
- Computing res = a − b:  __BN_sub(res, a, b)__
- Computing res = a + b:  __BN_add(res, a, b)__
- Computing res = a ∗ b:  __BN_mul(res, a, b, ctx)__
- Computing res = a ∗ b mod n:  __BN_mod_mul(res, a, b, n, ctx)__
- Computing res = a^c mod n:  __BN_mod_exp(res, a, c, n, ctx)__
- Computing modular inverse:  __BN_mod_inverse(b, a, n, ctx)__


Deriving the private key can be done by writing a Clang program that will calculate the private key using the OpenSSL BIGNUM library.

```c
#include <stdio.h>
#include <openssl/bn.h>

#define NBITS 256

void printBN(char *msg, BIGNUM * a)
{
    /* Use BN_bn2hex(a) for hex string
     * Use BN_bn2dec(a) for decimal string */
    char * number_str = BN_bn2hex(a);
    printf("%s %s\n", msg, number_str);
    OPENSSL_free(number_str);
}


int main ()
{
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *p = BN_new();       // large prime number
    BIGNUM *q = BN_new();       // large prime number
    BIGNUM *e = BN_new();       // public exponent
    BIGNUM *d = BN_new();       // private key
    BIGNUM *n = BN_new();       // modulus
    BIGNUM *one = BN_new();     // 1
    BIGNUM *res1 = BN_new();    // (p-1)
    BIGNUM *res2 = BN_new();    // (q-1)
    BIGNUM *totient = BN_new(); // (p-1) * (q-1)
    
    // Initialize p, q, and e
    BN_hex2bn(&p, "F7E75FDC469067FFDC4E847C51F452DF");
    BN_hex2bn(&q, "E85CED54AF57E53E092113E62F436F4F");
    BN_hex2bn(&e, "0D88C3");
    BN_hex2bn(&one, "01");
    
    // Compute the modulus, n = p*q
    BN_mul(n, p, q, ctx);
    
    // Calculate (p-1)
    BN_sub(res1, p, one);
    
    // Calculate (q-1)
    BN_sub(res2, q, one);  
    
    // Compute the totient function, totient = (p-1) * (q-1)
    BN_mul(totient, res1, res2, ctx);
    
    // Calculate the private key, d
    BN_mod_inverse(d, e, totient, ctx);
    printBN("Private key = ", d);
    
    return 0;
}
```

```bash
gcc rsa_privkey.c -lcrypto -o rsa_privkey
./rsa_privkey
```

After running the program, I got the private key as "3587A24598E5F2A21DB007D89D18CC50ABA5075BA19A33890FE7C28A9B496AEB".


<br>

### Encrypting a Message

This section of the lab involves encrypting a message using the receiver's public key. The public key will be calculated from the following:
- a public exponent (e): 010001
- a modulus (n): DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5

<details>
<summary><b>Note</b></summary>
<div markdown="1">

___
- The public key is (e, n).
- We need to convert the message to an ASCII string (hex equivalent)
- We also need to convert the hex string to a BIGNUM using the hex-to-bn API: BN_hex2bn()
</div></details>

The secret message to encode is: "This is a super secret message!"

The secret message can be converted to a hex string using the below Python code:

```bash
$ python3 -c 'print(bytes.hex("This is a super secret message!".encode("ascii")))'
```

"This is a super secret message!" = 54686973206973206120737570657220736563726574206d65737361676521. It is converted to a big number and  used to encrypt the message.

We encrypt the message by writing a Clang program to do that. We also verify that our encryption is correct by decrypting the cipher text with the private key the lab author provides.

```c
#include <stdio.h>
#include <openssl/bn.h>

#define NBITS 256

void printBN(char *msg, BIGNUM * a)
{
    /* Use BN_bn2hex(a) for hex string
     * Use BN_bn2dec(a) for decimal string */
    char * number_str = BN_bn2hex(a);
    printf("%s %s\n", msg, number_str);
    OPENSSL_free(number_str);
}


int main ()
{
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *c = BN_new();       // cipher text
    BIGNUM *M = BN_new();       // original message
    BIGNUM *e = BN_new();       // public exponent
    BIGNUM *d = BN_new();       // private key
    BIGNUM *n = BN_new();       // modulus
    BIGNUM *m = BN_new();       // decrypted message
    
    // Initialize e, n, M, and d
    BN_hex2bn(&e, "010001");
    BN_hex2bn(&n, "DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5");
    BN_hex2bn(&M, "54686973206973206120737570657220736563726574206d65737361676521"); //"This is a super secret message!"
    BN_hex2bn(&d, "74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D");
       
    // Compute cipher text, c = M^e mod n
    BN_mod_exp(c, M, e, n, ctx);
    printBN("Encrypted message = ", c);
    
    // Compute the deciphered text, m = c^d mod n
    BN_mod_exp(m, c, d, n, ctx);
    printBN("Original Message  = ", M);
    printBN("Decrypted Message = ", m);
    
    return 0;
}
```

```bash
gcc rsa_enc.c -lcrypto -o rsa_enc
./rsa_enc
```

After running the program, I got the following result:

```bash
Encrypted message =  DB9D180A2D11752D60A6200F1DFF22A8413E37F8D569F138C4FEFDDBFAF116ED
Original Message  =  54686973206973206120737570657220736563726574206D65737361676521
Decrypted Message =  54686973206973206120737570657220736563726574206D65737361676521
```


<br>

### Decrypting a Message

This section of the lab involves decrypting a secret message. The public/private keys used in this task are the same as the ones used in the encryption lab.
using the receiver's public key.

The values we would use in our program include:
- the public exponent (e): 010001
- the modulus (n): DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5
- the encrypted message (C): 8C0F971DF2F3672B28811407E2DABBE1DA0FEBBBDFC7DCB67396567EA1E2493F
- the private key (d): 74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D

We decrypt the message by writing a Clang program to do that.

```c
#include <stdio.h>
#include <openssl/bn.h>

#define NBITS 256

void printBN(char *msg, BIGNUM * a)
{
    /* Use BN_bn2hex(a) for hex string
     * Use BN_bn2dec(a) for decimal string */
    char * number_str = BN_bn2hex(a);
    printf("%s %s\n", msg, number_str);
    OPENSSL_free(number_str);
}


int main ()
{
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *C = BN_new();       // encrypted message
    BIGNUM *e = BN_new();       // public exponent
    BIGNUM *d = BN_new();       // private key
    BIGNUM *n = BN_new();       // modulus
    BIGNUM *m = BN_new();       // decrypted message
    
    // Initialize e, n, C, and d
    BN_hex2bn(&e, "010001");
    BN_hex2bn(&n, "DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5");
    BN_hex2bn(&C, "8C0F971DF2F3672B28811407E2DABBE1DA0FEBBBDFC7DCB67396567EA1E2493F");
    BN_hex2bn(&d, "74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D");
    
    // Compute the deciphered text, m = C^d mod n
    BN_mod_exp(m, C, d, n, ctx);
    printBN("Decrypted Message = ", m);
    
    return 0;
}
```

```bash
gcc rsa_dec.c -lcrypto -o rsa_dec
./rsa_dec
```

After running the program, I got the following result:

```bash
Decrypted Message =  50617373776F72642069732064656573
```

We still need to convert the hex output to its readable string equivalent. We do this using the below python code:

```bash
python3 -c 'print(bytes.fromhex("50617373776F72642069732064656573").decode("ascii"))'
```

Running the above code converts the hex string into "Password is dees"


<br>

### Signing a Message

The public/private keys used in this task are the same as the ones used in Task 2. Please generate a signature
for the following message (please directly sign this message, instead of signing its hash value):
M = I owe you $2000.






Please make a slight change to the message M, such as changing $2000 to $3000, and sign the modified message. Compare both signatures and describe what you observe.



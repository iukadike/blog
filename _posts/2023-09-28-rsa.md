---
layout: post
title: RSA Public-Key Encryption and Signature
excerpt: Public key infrastructure is a system of cryptographic keys, digital certificates, and certificate authorities that is used to verify the authenticity of digital information and ensure secure communication over networks. A PKI system uses a public key and a private key. While the public key is freely available and used to encrypt data or verify digital signatures, the private key is kept secret and used for decryption or creating digital signatures.
categories: [crypto, rsa]
---

![Encryption]({{ site.baseurl }}/images/featured-images/rsa.jpg)



### Diffie-Hellman Key Exchange

Diffie-Hellman key exchange is a protocol that enables two parties who have no prior knowledge of each other to exchange secret keys over an insecure communication channel through the use of modular exponentiation. It was invented by Whitfield Diffie and Martin Hellman in 1976.

The Diffie-Hellman key works as follows:
- Both parties, i.e. Alice and Bob, agree on a large prime number, `p`, and a generator, `g`, a smaller prime number. The values of `p` and `g` are public and can be known by any attacker.
- Alice picks a private key `x` which is less than `p`. Bob also picks a private key `y` which is less than `p`. These private keys are kept secret.
- Alice computes `A = g^a mod p`, and Bob computes `B = g^b mod p`. These are the public keys that both parties then exchange openly.
- Alice and Bob use the received public keys and their private keys to compute the same shared secret key. Alice computes `s = B^a mod p`, while Bob computes `s = A^b mod p`.
- Alice and Bob now have the same shared secret key, `g^(ab) mod p`, which can be used for symmetric encryption, such as AES, to ensure confidential communication over an insecure channel.

The security of the Diffie-Hellman key exchange is based on the difficulty of the discrete logarithm problem, which is the problem of finding the exponent in modular exponentiation. If an attacker intercepts the exchanged public keys or messages, they would need to solve the discrete logarithm problem, which is computationally infeasible for large prime numbers.


### The RSA Algorithm

The RSA (Rivest-Shamir-Adleman) algorithm is named after its creators: Ron Rivest, Adi Shamir, and Leonard Adleman. The RSA algorithm is based on the mathematical properties of prime numbers and involves the use of a public key for encryption and a private key for decryption.

The RSA algorithm generates the private and public as follows:
- Choose two distinct large prime numbers, p and q.
- Compute n = p * q. This number becomes the modulus for the public key and private key.
- Compute the totient function, φ(n) = (p-1) * (q-1).
- Find a number e, where 1 < e < φ(n) and gcd(e, φ(n)) = 1 (This means that e is relatively prime to φ(n)). This becomes the public key exponent (e)
- Compute the private key exponent (d) as the modular multiplicative inverse of e modulo φ(n), i.e., d ≡ e^(-1) mod φ(n).

RSA encrypts data as follows:
- Convert the plaintext message into a numerical value using a suitable scheme (e.g., ASCII).
- Encrypt the numerical value using the public key: c = m^e mod n, where m is the numeric representation of the plaintext message and c is the ciphertext.

RSA decrypts data as follows:
- Decrypt the ciphertext using the private key: m = c^d mod n, where m is the decrypted numerical value and c is the ciphertext.
- Convert the numerical value back into the plaintext message using the same scheme as in the encryption step.

The security of the RSA algorithm relies on the factorization of large composite numbers. It is computationally difficult and time-consuming to factorize a large number into its prime factors, making the algorithm secure against attacks.

<details>
<summary><b>Note</b></summary>

___
When the private key is used for encryption, it no longer serves the purpose of encryption, because anyone with the public key has access to the encrypted data. Instead, when a private key is used, it is used as a form of signature to show that the data is from the expected origin.
</details>

In this post, I aim to document my findings and observations while performing a SEED lab.


<br>

### Deriving the Private Key

This section of the lab involves deriving a private key from the following:
- a public exponent (e): 0D88C3
- a large prime number (p): F7E75FDC469067FFDC4E847C51F452DF
- a large prime number (q): E85CED54AF57E53E092113E62F436F4F

<details>
<summary><b>Note</b></summary>
<div markdown="1">

___
- The prime numbers used for this lab are 128 bits and are not large enough to be secure. However, 128 bits were selected to simplify the lab.
- In practice, these numbers should be at least 512 bits long.
</div></details>

The numbers involved in the RSA algorithms are typically more than 512 bits long and as such we cannot simply do `a * b`, but need to use an algorithm to compute their products. This lab makes use of the Big Number library provided by OpenSSL.

Using this library is straightforward. We define each big number as a BIGNUM type:
- A structure created to hold BIGNUM temporary variables used by library functions: __BN_CTX *ctx = BN_CTX_new()__
- Initialize a BIGNUM variable: __BIGNUM *a = BN_new()__

And then use the APIs provided by the library for various operations, such as:
- Computing res = a − b:  __BN_sub(res, a, b)__
- Computing res = a + b:  __BN_add(res, a, b)__
- Computing res = a ∗ b:  __BN_mul(res, a, b, ctx)__
- Computing res = a ∗ b mod n:  __BN_mod_mul(res, a, b, n, ctx)__
- Computing res = a^c mod n:  __BN_mod_exp(res, a, c, n, ctx)__
- Computing modular inverse:  __BN_mod_inverse(b, a, n, ctx)__


Deriving the private key can be done by writing a Clang program that will calculate the private key using the OpenSSL BIGNUM library.

```c
#include <stdio.h>
#include <openssl/bn.h>

#define NBITS 256

void printBN(char *msg, BIGNUM * a)
{
    /* Use BN_bn2hex(a) for hex string
     * Use BN_bn2dec(a) for decimal string */
    char * number_str = BN_bn2hex(a);
    printf("%s %s\n", msg, number_str);
    OPENSSL_free(number_str);
}


int main ()
{
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *p = BN_new();
    BIGNUM *q = BN_new();
    BIGNUM *e = BN_new();
    BIGNUM *d = BN_new();
    BIGNUM *n = BN_new();
    BIGNUM *one = BN_new();
    BIGNUM *res1 = BN_new();
    BIGNUM *res2 = BN_new();
    BIGNUM *totient = BN_new();
    
    // Initialize p, q, and e
    BN_hex2bn(&p, "F7E75FDC469067FFDC4E847C51F452DF");
    BN_hex2bn(&q, "E85CED54AF57E53E092113E62F436F4F");
    BN_hex2bn(&e, "0D88C3");
    BN_hex2bn(&one, "01");
    
    // Compute the modulus, n = p*q
    BN_mul(n, p, q, ctx);
    
    // Calculate (p-1)
    BN_sub(res1, p, one);
    
    // Calculate (q-1)
    BN_sub(res2, q, one);  
    
    // Compute the totient function, totient = (p-1) * (q-1)
    BN_mul(totient, res1, res2, ctx);
    
    // Calculate the private key, d
    BN_mod_inverse(d, e, totient, ctx);
    printBN("Private key = ", d);
    
    return 0;
}
```

```bash
gcc rsa_privkey.c -lcrypto -o rsa_privkey
./rsa_privkey
```

After running the program, I got the private key as "3587A24598E5F2A21DB007D89D18CC50ABA5075BA19A33890FE7C28A9B496AEB".


<br>

### Encrypting a Message

This section of the lab involves encrypting a message using the public key of the receiver. The public key will be calculated from the following:
- a public exponent (e): 010001
- a modulus (n): DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5

<details>
<summary><b>Note</b></summary>
<div markdown="1">

___
- The public key is (e, n).
- We need to convert the message which is an ASCII string to a hex string
- We also need to convert the hex string to a BIGNUM using the hex-to-bn API: BN_hex2bn()
</div></details>

The secret message to encode is: "This is a super secret message!"

The secret message can be converted to a hex string using the below python code:

```bash
$ python -c "print('This is a super secret message!'.encode('hex'))"
```

The result of the above code is ... and it is used in the clang code to convert it to a big number and encrypt the message.


Let (e, n) be the public key. Please encrypt the message "A top secret!" (the quotations are not
included). We need to convert this ASCII string to a hex string, and then convert the hex string to a BIGNUM
using the hex-to-bn API BN hex2bn(). The following Python command can be used to convert a plain
ASCII string to a hex string.
$ python -c ’print("A top secret!".encode("hex"))’
4120746f702073656372657421
SEED Labs – RSA Public-Key Encryption and Signature Lab 5
The public keys are listed in the following (hexadecimal). We also provide the private key d to help
you verify your encryption result.
n = DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5
e = 010001 (this hex value equals decimal 65537)
M = A top secret!
d = 74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D

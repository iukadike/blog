---
layout: post
title: RSA Public-Key Encryption and Signature
excerpt: Public key infrastructure is a system of cryptographic keys, digital certificates, and certificate authorities that is used to verify the authenticity of digital information and ensure secure communication over networks. A PKI system uses a public key and a private key. While the public key is freely available and used to encrypt data or verify digital signatures, the private key is kept secret and used for decryption or creating digital signatures.
categories: [crypto, rsa]
---

![Encryption]({{ site.baseurl }}/images/featured-images/rsa.jpg)



### Diffie-Hellman Key Exchange

Diffie-Hellman key exchange is a protocol that enables two parties who have no prior knowledge of each other to exchange secret keys over an insecure communication channel through the use of modular exponentiation. It was invented by Whitfield Diffie and Martin Hellman in 1976.

The Diffie-Hellman key works as follows:
- Both parties, i.e. Alice and Bob, agree on a large prime number, `p`, and a generator, `g`, a smaller prime number. The values of `p` and `g` are public and can be known by any attacker.
- Alice picks a private key `x` which is less than `p`. Bob also picks a private key `y` which is less than `p`. These private keys are kept secret.
- Alice computes `A = g^a mod p`, and Bob computes `B = g^b mod p`. These are the public keys that both parties then exchange openly.
- Alice and Bob use the received public keys and their private keys to compute the same shared secret key. Alice computes `s = B^a mod p`, while Bob computes `s = A^b mod p`.
- Alice and Bob now have the same shared secret key, `g^(ab) mod p`, which can be used for symmetric encryption, such as AES, to ensure confidential communication over an insecure channel.

The security of the Diffie-Hellman key exchange is based on the difficulty of the discrete logarithm problem, which is the problem of finding the exponent in modular exponentiation. If an attacker intercepts the exchanged public keys or messages, they would need to solve the discrete logarithm problem, which is computationally infeasible for large prime numbers.


### The RSA Algorithm

The RSA (Rivest-Shamir-Adleman) algorithm is named after its creators: Ron Rivest, Adi Shamir, and Leonard Adleman. The RSA algorithm is based on the mathematical properties of prime numbers and involves the use of a public key for encryption and a private key for decryption.

The RSA algorithm generates the private and public as follows:
- Choose two distinct large prime numbers, p and q.
- Compute n = p * q. This number becomes the modulus for the public key and private key.
- Compute the totient function, φ(n) = (p-1) * (q-1).
- Find a number e, where 1 < e < φ(n) and gcd(e, φ(n)) = 1 (This means that e is relatively prime to φ(n)). This becomes the public key exponent (e)
- Compute the private key exponent (d) as the modular multiplicative inverse of e modulo φ(n), i.e., d ≡ e^(-1) mod φ(n).

RSA encrypts data as follows:
- Convert the plaintext message into a numerical value using a suitable scheme (e.g., ASCII).
- Encrypt the numerical value using the public key: c = m^e mod n, where m is the numeric representation of the plaintext message and c is the ciphertext.

RSA decrypts data as follows:
- Decrypt the ciphertext using the private key: m = c^d mod n, where m is the decrypted numerical value and c is the ciphertext.
- Convert the numerical value back into the plaintext message using the same scheme as in the encryption step.

The security of the RSA algorithm relies on the factorization of large composite numbers. It is computationally difficult and time-consuming to factorize a large number into its prime factors, making the algorithm secure against attacks.

<details>
<summary><b>Note</b></summary>

___
When the private key is used for encryption, it no longer serves the purpose of encryption, because anyone with the public key has access to the encrypted data. Instead, when a private key is used, it is used as a form of signature to show that the data is from the expected origin.
</details>

In this post, I aim to document my findings and observations while performing a SEED lab.


<br>

### Deriving the Private Key

This section of the lab involves deriving a private key from the following:
- a public exponent (e): 0D88C3
- a large prime number (p): F7E75FDC469067FFDC4E847C51F452DF
- a large prime number (q): E85CED54AF57E53E092113E62F436F4F

<details>
<summary><b>Note</b></summary>
<div markdown="1">

___
- The prime numbers used for this lab are 128 bits and are not large enough to be secure. However, 128 bits were selected to simplify the lab.
- In practice, these numbers should be at least 512 bits long.
</div></details>

The numbers involved in the RSA algorithms are typically more than 512 bits long and as such we cannot simply do `a * b`, but need to use an algorithm to compute their products. This lab makes use of the Big Number library provided by OpenSSL.

Using this library is straightforward. We define each big number as a BIGNUM type:
- A structure created to hold BIGNUM temporary variables used by library functions: __BN_CTX *ctx = BN_CTX_new()__
- Initialize a BIGNUM variable: __BIGNUM *a = BN_new()__

And then use the APIs provided by the library for various operations, such as:
- Computing res = a − b:  __BN_sub(res, a, b)__
- Computing res = a + b:  __BN_add(res, a, b)__
- Computing res = a ∗ b:  __BN_mul(res, a, b, ctx)__
- Computing res = a ∗ b mod n:  __BN_mod_mul(res, a, b, n, ctx)__
- Computing res = a^c mod n:  __BN_mod_exp(res, a, c, n, ctx)__
- Computing modular inverse:  __BN_mod_inverse(b, a, n, ctx)__


Deriving the private key can be done by writing a Clang program that will calculate the private key using the OpenSSL BIGNUM library.

```c
#include <stdio.h>
#include <openssl/bn.h>

#define NBITS 256

void printBN(char *msg, BIGNUM * a)
{
    /* Use BN_bn2hex(a) for hex string
     * Use BN_bn2dec(a) for decimal string */
    char * number_str = BN_bn2hex(a);
    printf("%s %s\n", msg, number_str);
    OPENSSL_free(number_str);
}


int main ()
{
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *p = BN_new();       // large prime number
    BIGNUM *q = BN_new();       // large prime number
    BIGNUM *e = BN_new();       // public exponent
    BIGNUM *d = BN_new();       // private key
    BIGNUM *n = BN_new();       // modulus
    BIGNUM *one = BN_new();     // 1
    BIGNUM *res1 = BN_new();    // (p-1)
    BIGNUM *res2 = BN_new();    // (q-1)
    BIGNUM *totient = BN_new(); // (p-1) * (q-1)
    
    // Initialize p, q, and e
    BN_hex2bn(&p, "F7E75FDC469067FFDC4E847C51F452DF");
    BN_hex2bn(&q, "E85CED54AF57E53E092113E62F436F4F");
    BN_hex2bn(&e, "0D88C3");
    BN_hex2bn(&one, "01");
    
    // Compute the modulus, n = p*q
    BN_mul(n, p, q, ctx);
    
    // Calculate (p-1)
    BN_sub(res1, p, one);
    
    // Calculate (q-1)
    BN_sub(res2, q, one);  
    
    // Compute the totient function, totient = (p-1) * (q-1)
    BN_mul(totient, res1, res2, ctx);
    
    // Calculate the private key, d
    BN_mod_inverse(d, e, totient, ctx);
    printBN("Private key = ", d);
    
    return 0;
}
```

```bash
gcc rsa_privkey.c -lcrypto -o rsa_privkey
./rsa_privkey
```

After running the program, I got the private key as "3587A24598E5F2A21DB007D89D18CC50ABA5075BA19A33890FE7C28A9B496AEB".


<br>

### Encrypting a Message

This section of the lab involves encrypting a message using the receiver's public key. The public key will be calculated from the following:
- a public exponent (e): 010001
- a modulus (n): DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5

<details>
<summary><b>Note</b></summary>
<div markdown="1">

___
- The public key is (e, n).
- We need to convert the message to an ASCII string (hex equivalent)
- We also need to convert the hex string to a BIGNUM using the hex-to-bn API: BN_hex2bn()
</div></details>

The secret message to encode is: "This is a super secret message!"

The secret message can be converted to a hex string using the below Python code:

```bash
$ python3 -c 'print(bytes.hex("This is a super secret message!".encode("ascii")))'
```

"This is a super secret message!" = 54686973206973206120737570657220736563726574206d65737361676521. It is converted to a big number and  used to encrypt the message.

We encrypt the message by writing a Clang program to do that. We also verify that our encryption is correct by decrypting the cipher text with the private key the lab author provides.

```c
#include <stdio.h>
#include <openssl/bn.h>

#define NBITS 256

void printBN(char *msg, BIGNUM * a)
{
    /* Use BN_bn2hex(a) for hex string
     * Use BN_bn2dec(a) for decimal string */
    char * number_str = BN_bn2hex(a);
    printf("%s %s\n", msg, number_str);
    OPENSSL_free(number_str);
}


int main ()
{
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *c = BN_new();       // cipher text
    BIGNUM *M = BN_new();       // original message
    BIGNUM *e = BN_new();       // public exponent
    BIGNUM *d = BN_new();       // private key
    BIGNUM *n = BN_new();       // modulus
    BIGNUM *m = BN_new();       // decrypted message
    
    // Initialize e, n, M, and d
    BN_hex2bn(&e, "010001");
    BN_hex2bn(&n, "DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5");
    BN_hex2bn(&M, "54686973206973206120737570657220736563726574206d65737361676521"); //"This is a super secret message!"
    BN_hex2bn(&d, "74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D");
       
    // Compute cipher text, c = M^e mod n
    BN_mod_exp(c, M, e, n, ctx);
    printBN("Encrypted message = ", c);
    
    // Compute the deciphered text, m = c^d mod n
    BN_mod_exp(m, c, d, n, ctx);
    printBN("Original Message  = ", M);
    printBN("Decrypted Message = ", m);
    
    return 0;
}
```

```bash
gcc rsa_enc.c -lcrypto -o rsa_enc
./rsa_enc
```

After running the program, I got the following result:

```bash
Encrypted message =  DB9D180A2D11752D60A6200F1DFF22A8413E37F8D569F138C4FEFDDBFAF116ED
Original Message  =  54686973206973206120737570657220736563726574206D65737361676521
Decrypted Message =  54686973206973206120737570657220736563726574206D65737361676521
```


<br>

### Decrypting a Message

This section of the lab involves decrypting a secret message. The public/private keys used in this task are the same as the ones used in the encryption lab.
using the receiver's public key.

The values we would use in our program include:
- the public exponent (e): 010001
- the modulus (n): DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5
- the encrypted message (C): 8C0F971DF2F3672B28811407E2DABBE1DA0FEBBBDFC7DCB67396567EA1E2493F
- the private key (d): 74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D

We decrypt the message by writing a Clang program to do that.

```c
#include <stdio.h>
#include <openssl/bn.h>

#define NBITS 256

void printBN(char *msg, BIGNUM * a)
{
    /* Use BN_bn2hex(a) for hex string
     * Use BN_bn2dec(a) for decimal string */
    char * number_str = BN_bn2hex(a);
    printf("%s %s\n", msg, number_str);
    OPENSSL_free(number_str);
}


int main ()
{
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *C = BN_new();       // encrypted message
    BIGNUM *e = BN_new();       // public exponent
    BIGNUM *d = BN_new();       // private key
    BIGNUM *n = BN_new();       // modulus
    BIGNUM *m = BN_new();       // decrypted message
    
    // Initialize e, n, C, and d
    BN_hex2bn(&e, "010001");
    BN_hex2bn(&n, "DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5");
    BN_hex2bn(&C, "8C0F971DF2F3672B28811407E2DABBE1DA0FEBBBDFC7DCB67396567EA1E2493F");
    BN_hex2bn(&d, "74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D");
    
    // Compute the deciphered text, m = C^d mod n
    BN_mod_exp(m, C, d, n, ctx);
    printBN("Decrypted Message = ", m);
    
    return 0;
}
```

```bash
gcc rsa_dec.c -lcrypto -o rsa_dec
./rsa_dec
```

After running the program, I got the following result:

```bash
Decrypted Message =  50617373776F72642069732064656573
```

We still need to convert the hex output to its readable string equivalent. We do this using the below python code:

```bash
python3 -c 'print(bytes.fromhex("50617373776F72642069732064656573").decode("ascii"))'
```

Running the above code converts the hex string into "Password is dees"


<br>

### Signing a Message

This section of the lab involves signing a message using the private key of the correspondent. The public/private keys used in this task are the same as the ones used in the encryption lab.

We would directly sign the message, instead of signing its hash value.

The values we would use in our program include:
- the public exponent (e): 010001
- the modulus (n): DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5
- the private key (d): 74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D

The message to sign is: "I owe you $2000." The message can be converted to a hex string using the below Python code:

```bash
$ python3 -c 'print(bytes.hex("I owe you $2000.".encode("ascii")))'
```

"I owe you $2000." = 49206f776520796f752024323030302e.

An alternate message that is a slight variation of the original message will also be signed: "I owe you $3000." The alternate message can be converted to a hex string using the below Python code:

```bash
$ python3 -c 'print(bytes.hex("I owe you $3000.".encode("ascii")))'
```

"I owe you $3000." = 49206f776520796f752024333030302e.

The below Clang program signs both messages:

```c
#include <stdio.h>
#include <openssl/bn.h>

#define NBITS 256

void printBN(char *msg, BIGNUM * a)
{
    /* Use BN_bn2hex(a) for hex string
     * Use BN_bn2dec(a) for decimal string */
    char * number_str = BN_bn2hex(a);
    printf("%s %s\n", msg, number_str);
    OPENSSL_free(number_str);
}


int main ()
{
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *c = BN_new();       // digital signature
    BIGNUM *M = BN_new();       // message to sign
    BIGNUM *m = BN_new();       // alt message to sign
    BIGNUM *d = BN_new();       // private key
    BIGNUM *n = BN_new();       // modulus
    
    // Initialize n, m, and d
    BN_hex2bn(&n, "DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5");
    BN_hex2bn(&M, "49206f776520796f752024323030302e"); // "I owe you $2000."
    BN_hex2bn(&m, "49206f776520796f752024333030302e"); // "I owe you $3000."
    BN_hex2bn(&d, "74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D");
       
    // Compute the digital signature, c = M^d mod n
    BN_mod_exp(c, M, d, n, ctx);
    printBN("Digital signature for \"I owe you $2000.\" = ", c);
    BN_mod_exp(c, m, d, n, ctx);
    printBN("Digital signature for \"I owe you $3000.\" = ", c);
        
    return 0;
}
```

```bash
gcc rsa_sign.c -lcrypto -o rsa_sign
./rsa_sign
```

After running the program, I got the following result:

```bash
Digital signature for "I owe you $2000." =  55A4E7F17F04CCFE2766E1EB32ADDBA890BBE92A6FBE2D785ED6E73CCB35E4CB
Digital signature for "I owe you $3000." =  BCC20FB7568E5D48E434C387C06A6025E90D29D848AF9C3EBAC0135D99305822
```

The following can be observed:
- The variation in the original message and the alternative message seems rather insignificant from the output of their hex code.
- However, when both messages are signed, there is a significant variation in the digital signature of both messages.
- This means that even the most insignificant change in a message will cause obvious changes in a digital signature.


<br>

### Verifying a Signature

This section of the lab involves verifying the signature of a message using the public key of the correspondent. The public/private keys used in this task are the same as the ones used in the encryption lab.

Bob receives a message M = "Launch a missile." from Alice, with her signature S. We need to verify whether the signature is indeed Alice's or not.

The following values are used:
- the public exponent (e): 010001
- the modulus (n): AE1CD4DC432798D933779FBD46C6E1247F0CF1233595113AA51B450F18116115
- the digital signature (S): 643D6F34902D9C7EC90CB0B2BCA36C47FA37165C0005CAB026C0542CBDB6802F
- the message (M) = "Launch a missile."

The message with a digital signature to verify is: "Launch a missile." The message can be converted to a hex string using the below Python code:

```bash
$ python3 -c 'print(bytes.hex("I owe you $2000.".encode("ascii")))'
```

"I owe you $2000." = 49206f776520796f752024323030302e.


We can verify the digital signature received with the message to find out if it was indeed Alice who sent the message using the below clang code:

```c
#include <stdio.h>
#include <openssl/bn.h>

#define NBITS 256

char* isValid(BIGNUM *a, BIGNUM *b);

void printBN(char *msg, BIGNUM * a)
{
    /* Use BN_bn2hex(a) for hex string
     * Use BN_bn2dec(a) for decimal string */
    char * number_str = BN_bn2hex(a);
    printf("%s %s\n", msg, number_str);
    OPENSSL_free(number_str);
}


int main ()
{
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *S = BN_new();       // digital signature
    BIGNUM *e = BN_new();       // public exponent
    BIGNUM *m = BN_new();       // decrypted message
    BIGNUM *n = BN_new();       // modulus
    BIGNUM *M = BN_new();       // message to verify
    
    // Initialize e, n, S, and M
    BN_hex2bn(&e, "010001");
    BN_hex2bn(&n, "AE1CD4DC432798D933779FBD46C6E1247F0CF1233595113AA51B450F18116115");
    BN_hex2bn(&S, "643D6F34902D9C7EC90CB0B2BCA36C47FA37165C0005CAB026C0542CBDB6802F");
    BN_hex2bn(&M, "4c61756e63682061206d697373696c652e");
    
    // Compute the deciphered text, m = C^d mod n
    BN_mod_exp(m, S, e, n, ctx);
    printBN("Computed Message = ", m);
    printBN("Received Message = ", M);
    printf("%s", isValid(m, M));
    
    return 0;
}

char* isValid(BIGNUM *a, BIGNUM *b)
{
    if (BN_cmp(a, b) == 0){
        return "The message is from Alice!\n";
    } else {
        return "The message is not from Alice!\n";
    }
}
```

```bash
gcc rsa_vrfy.c -lcrypto -o rsa_vrfy
./rsa_vrfy
```

After running the program, I got the following result:

```bash
Computed Message =  4C61756E63682061206D697373696C652E
Received Message =  4C61756E63682061206D697373696C652E
The message is from Alice!
```

We can be sure that the message actually came from Alice. Suppose that Alice's signature above is corrupted, such that the last byte of the signature changes from 2F
to 3F (there is only one bit of change), we can check to see if the verification will pass.

Alice signature:     643D6F34902D9C7EC90CB0B2BCA36C47FA37165C0005CAB026C0542CBDB6802F
Corrupted signature: 643D6F34902D9C7EC90CB0B2BCA36C47FA37165C0005CAB026C0542CBDB6803F

When we substitute Alice's signature with the corrupted signature in the Clang program, compile it, and run it, we get the below results:

```bash
Computed Message =  91471927C80DF1E42C154FB4638CE8BC726D3D66C83A4EB6B7BE0203B41AC294
Received Message =  4C61756E63682061206D697373696C652E
The message is not from Alice!
```


<br>

### Manually Verifying an X.509 Certificate

This section of the lab involves verifying the signature of a message using the public key of the correspondent. The public/private keys used in this task are the same as the ones used in the encryption lab.


In this task, we will manually verify an X.509 certificate using our program. An X.509 contains data about
a public key and an issuer’s signature on the data. We will download a real X.509 certificate from a web
server, get its issuer’s public key, and then use this public key to verify the signature on the certificate.

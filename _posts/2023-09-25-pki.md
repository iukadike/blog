---
layout: post
title: Public Key Infrastructure
excerpt: Public key infrastructure is a system of cryptographic keys, digital certificates, and certificate authorities that is used to verify the authenticity of digital information and ensure secure communication over networks. A PKI system uses a public key and a private key. While the public key is freely available and used to encrypt data or verify digital signatures, the private key is kept secret and used for decryption or creating digital signatures.
categories: [crypto, mitm]
---

![PKI]({{ site.baseurl }}/images/featured-images/pki.jpg)


Public key infrastructure is a system of cryptographic keys, digital certificates, and certificate authorities that is used to verify the authenticity of digital information and ensure secure communication over networks.

A PKI system uses a public key and a private key. While the public key is freely available and used to encrypt data or verify digital signatures, the private key is kept secret and used for decryption or creating digital signatures.

A PKI system is usually made up of the following components:
- **Certificate Authority (CA)**: A CA is a trusted third-party that is responsible for issuing digital certificates.
- **Digital Certificate**: A digital certificate is used to validate the identity of individuals, organizations, or devices. Digital certificates make use of the X.509 standard. A digital certificate usually contains the following:
  - **Public Key**: The public key is made available to anyone who wishes to encrypt messages for the certificate holder or verify their digital signatures.
  - **Issuer**: Information about the CA who issues the certificate.
  - **Subject**: Information about the certificate holder's identity, such as the organization name, email address, and other relevant identifying details of the individual or entity being certified. This allows third parties to confirm the identity of the certificate holder.
  - **Validity Period**: Information about when the certificate should be considered valid; It typically has an expiration date, after which it needs to be renewed to continue to be trusted.
  - **Signature**: This is the digital signature of the CA that issues the certificate.
  - **Serial number**: this is a unique number that distinguishes the certificate from other certificates.
  - **Extensions**: Newer versions of the X.509 certificates contain optional extension fields.
- **Certificate Signing Request (CSR)**: A CSR is a file that contains the public key and other identifying information (such as its domain name, organization details, and contact information) of the entity that is applying for a digital certificate from a Certificate Authority.

<details>
<summary><b>Getting a certificate from a real server</b></summary>
<div markdown="1">

___
First, get the certificate

```bash
openssl s_client -showcerts -connect www.meta.com:443 </dev/null
```

An actual X.509 certificate contains binary data, making it difficult to print or view. Therefore, when stored in files, they are often encoded using base64.

The best way to view an X.509 certificate is to save the base64 PEM content into a `.pem` file and use openssl to convert the content into text.

```bash
openssl x509 -in meta.pem -text -noout
```
___
</div></details>


The public key infrastructure (PKI) helps enforce the CIA triad.
- **Confidentiality**: using public keys ensures that only the intended recipient can decrypt and read the data.
- **Integrity**: Digital signatures created using private keys help ensure that data has not been tampered with during transmission.
- **Authentication**: PKI verifies the identities of individuals or entities in digital communications, reducing the risk of impersonation or fraud.


In this post, I aim to document my findings and observations while performing a SEED lab.


<br>

### Becoming a Certificate Authority (CA)

A Certificate Authority (CA) is a trusted entity that issues digital certificates. The CA acts as a reliable third party that validates the identity of the certificate requester and issues the certificate after a thorough verification process. This process involves verifying the requester's ownership of the domain (in the case of website certificates), confirming their legal existence (in the case of organization certificates), or verifying their identity (in the case of personal certificates).

CAs form a hierarchical structure, where some are considered root CAs, and they issue certificates to intermediate CAs. Intermediate CAs, in turn, issue certificates to end-users, such as websites or individuals.

The core functions of a CA consist of:
1. Verifying the certificate requester
2. Issuing digitally signed X.509 certificates

This lab section involves taking on the role of a root CA and using this CA to issue digital certificates to other entities using OpenSSL.

Unlike other certificates, which are usually signed by another CA, the root CA’s certificates are self-signed and usually pre-loaded into most operating systems, web browsers, and other software that rely on PKI. This is because a root CA’s certificates are unconditionally trusted.

We need to copy the default config file for OpenSSL to our working directory. It is this copy we would make changes to and use when running our commands.

```bash
cp /usr/lib/ssl/openssl.cnf `pwd`
```

We have to create the following files in the working directory:
- an empty file called index.txt
- a file called serial that contains a number format (e.g., 100000) in the file.
- a folder called newcerts

Other adjustments can be made to the config file as seen fit.

The following command generates a self-signed certificate for our CA:

```bash
openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -keyout ca.key -out ca.crt
```

<details>
<summary><b>Command Explanation</b></summary>
<div markdown="1">

___
- **req**: Specifies that we want to use the certificate request (CSR) utility.
- **-x509**: Generates a self-signed certificate instead of a certificate request.
- **-newkey rsa:4096**: Creates a new private key using the RSA algorithm with a 4096-bit key length.
- **-sha256**: Uses the SHA-256 hashing algorithm to sign the certificate.
- **-days 3650**: Specifies the validity period of the certificate in days, in this case, 3650 days (approximately 10 years).
- **-keyout ca.key**: Specifies the file name of the private key to be generated (in this case, "ca.key").
- **-out ca.crt**: Specifies the file name of the self-signed certificate to be generated (in this case, "ca.crt").
___

</div></details>

The "ca.key" file contains the CA’s private key, while the "ca.crt" file contains the public-key certificate.

To view the decoded content of the X509 certificate and the RSA key, we use the following commands:

```bash
openssl x509 -in ca.crt -text -noout
openssl rsa -in ca.key -text -noout
```

where:
- **-text**: means decoding the content into plain text
- **-noout**: means not printing out the encoded version

From the output of the commands above, we can observe the following:
- The digital certificate belongs to a CA because `CA:TRUE` is set under the extensinons component.
  **image**
- The digital certificate is a self-signed certificate
  **image**
- The digital certificate contains the modulus and the public exponent
  **image**
  **image**
- The private key contains the following:
  - a public exponent (e)
  - a private exponent (d)
  - a modulus (n)
  - two secret numbers p and q, such that n = pq. 


<br>

### Generating a Certificate Request for Your Web Server

This lab section involves requesting an X509 certificate from our CA.

A company called ukadike32 wants to get a public key certificate from our CA for its webserver, `www.ukadike32.com`. The first step is to generate a Certificate Signing Request (CSR), which basically includes the company's public key and identity information. The CSR will be sent to the CA, who will verify the identity information in the request and then generate a certificate.

Many websites have different URLs that point to the same web server. Due to the hostname matching policy enforced by browsers, the common name in a certificate must match the server’s hostname, or browsers will refuse to communicate with the server.

Using the Subject Alternative Name (SAN) extension, it is possible to specify several hostnames in the subjectAltName field of a certificate. The subjectAltName extension field must also include the hostname from the common name field; otherwise, the common name will not be accepted as a valid name.

Our CSR for `www.ukadike32.com` will include two alternative names.

```bash
openssl req -newkey rsa:2048 -sha256 -keyout server.key -out server.csr \
-addext "subjectAltName = DNS:www.ukadike32.com, \
DNS:www.ukadike32A.com, DNS:www.ukadike32B.com"
```

The "server.key" file contains ukadike32's private key, while the "server.csr" file contains the CSR.

To view the decoded content of the X509 certificate and the RSA key, we use the following commands:

```bash
openssl req -in server.csr -text -noout
openssl rsa -in server.key -text -noout
```

**image**


<br>

### Generating a Certificate for your server

This lab section involves issuing an X509 certificate from our CA for an entity.

The CSR file needs to contain the CA’s signature to become a certificate. The CA uses its digital certificate and private key to sign the CSR. This is done through the following command:

<details>
<summary><b>Lab Environment</b></summary>
<div markdown="1">

___
In the below command, modalCA openssl.cnf is the configuration file we copied from /usr/lib/ssl/openssl.cnf and made changes to. For the purpose of this lab, we use the following:
- We use the policy_anything policy defined in the configuration file to bypass the restrictions placed by the default policy. This policy does not enforce any matching rule in the subject name of the CSR and the X509 certificate.
- set "copy_extensions = copy" in the config file. For security reasons, the default setting in openssl.cnf does not allow the "openssl ca" command to copy the extension field from the request to the final certificate.
___

</div></details>

```bash
openssl ca -config modalCA_openssl.cnf -policy policy_anything \
-md sha256 -days 3650 \
-in server.csr -out server.crt -batch \
-cert ca.crt -keyfile ca.key
```

After signing the certificate, we can print out the decoded content of the certificate to check whether the alternative names are included.

```bash
openssl x509 -in server.crt -text -noout
```

**image**

**image**


<br>

### Deploying Certificate in an Apache-Based HTTPS Website

In this task, we will see how public-key certificates are used by websites to secure web browsing. We will
set up an HTTPS website based Apache. The Apache server, which is already installed in our container,
supports the HTTPS protocol. To create an HTTPS website, we just need to configure the Apache server,
so it knows where to get the private key and certificates. Inside our container, we have already set up an
HTTPS site for bank32.com. Students can follow this example to set up their own HTTPS site.
An Apache server can simultaneously host multiple websites. It needs to know the directory where
a website’s files are stored. This is done via its VirtualHost file, located in the /etc/apache2/
sites-available directory. In our container, we have a file called bank32 apache ssl.conf,
which contains the following entry:













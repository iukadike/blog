---
layout: post
title: Public Key Infrastructure
excerpt: Public key infrastructure is a system of cryptographic keys, digital certificates, and certificate authorities that is used to verify the authenticity of digital information and ensure secure communication over networks. A PKI system uses a public key and a private key. While the public key is freely available and used to encrypt data or verify digital signatures, the private key is kept secret and used for decryption or creating digital signatures.
categories: [crypto, mitm]
---

![PKI]({{ site.baseurl }}/images/featured-images/pki.jpg)


Public key infrastructure is a system of cryptographic keys, digital certificates, and certificate authorities that is used to verify the authenticity of digital information and ensure secure communication over networks.

A PKI system uses a public key and a private key. While the public key is freely available and used to encrypt data or verify digital signatures, the private key is kept secret and used for decryption or creating digital signatures.

A PKI system is usually made up of the following components:
- **Certificate Authority (CA)**: A CA is a trusted third-party that is responsible for issuing digital certificates.
- **Digital Certificate**: A digital certificate is used to validate the identity of individuals, organizations, or devices. Digital certificates make use of the X.509 standard. A digital certificate usually contains the following:
  - **Public Key**: The public key is made available to anyone who wishes to encrypt messages for the certificate holder or verify their digital signatures.
  - **Issuer**: Information about the CA who issues the certificate.
  - **Subject**: Information about the certificate holder's identity, such as the organization name, email address, and other relevant identifying details of the individual or entity being certified. This allows third parties to confirm the identity of the certificate holder.
  - **Validity Period**: Information about when the certificate should be considered valid; It typically has an expiration date, after which it needs to be renewed to continue to be trusted.
  - **Signature**: This is the digital signature of the CA that issues the certificate.
  - **Serial number**: this is a unique number that distinguishes the certificate from other certificates.
  - **Extensions**: Newer versions of the X.509 certificates contain optional extension fields.
- **Certificate Signing Request (CSR)**: A CSR is a file that contains the public key and other identifying information (such as its domain name, organization details, and contact information) of the entity that is applying for a digital certificate from a Certificate Authority.

<details>
<summary><b>Getting a certificate from a real server</b></summary>
<div markdown="1">

___
First, get the certificate

```bash
openssl s_client -showcerts -connect www.meta.com:443 </dev/null
```

An actual X.509 certificate contains binary data, making it difficult to print or view. Therefore, when stored in files, they are often encoded using base64.

The best way to view an X.509 certificate is to save the base64 PEM content into a `.pem` file and use openssl to convert the content into text.

```bash
openssl x509 -in meta.pem -text -noout
```
___
</div></details>


The public key infrastructure (PKI) helps enforce the CIA triad.
- **Confidentiality**: using public keys ensures that only the intended recipient can decrypt and read the data.
- **Integrity**: Digital signatures created using private keys help ensure that data has not been tampered with during transmission.
- **Authentication**: PKI verifies the identities of individuals or entities in digital communications, reducing the risk of impersonation or fraud.


In this post, I aim to document my findings and observations while performing a SEED lab.


<br>

### Becoming a Certificate Authority (CA)

A Certificate Authority (CA) is a trusted entity that issues digital certificates. The CA acts as a reliable third party that validates the identity of the certificate requester and issues the certificate after a thorough verification process. This process involves verifying the requester's ownership of the domain (in the case of website certificates), confirming their legal existence (in the case of organization certificates), or verifying their identity (in the case of personal certificates).

CAs form a hierarchical structure, where some are considered root CAs, and they issue certificates to intermediate CAs. Intermediate CAs, in turn, issue certificates to end-users, such as websites or individuals.

The core functions of a CA consist of:
1. Verifying the certificate requester
2. Issuing digitally signed X.509 certificates

This lab section involves taking on the role of a root CA and using this CA to issue digital certificates to other entities using OpenSSL.

Unlike other certificates, which are usually signed by another CA, the root CA’s certificates are self-signed and usually pre-loaded into most operating systems, web browsers, and other software that rely on PKI. This is because a root CA’s certificates are unconditionally trusted.

We need to copy the default config file for OpenSSL to our working directory. It is this copy we would make changes to and use when running our commands.

```bash
cp /usr/lib/ssl/openssl.cnf `pwd`
```

We have to create the following files in the working directory:
- an empty file called index.txt
- a file called serial that contains a number format (e.g., 100000) in the file.
- a folder called newcerts

Other adjustments can be made to the config file as seen fit.

The following command generates a self-signed certificate for our CA (which we will call ModalCA):

```bash
openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -keyout modalCA.key -out modalCA.crt
```

<details>
<summary><b>Command Explanation</b></summary>
<div markdown="1">

___
- **req**: Specifies that we want to use the certificate request (CSR) utility.
- **-x509**: Generates a self-signed certificate instead of a certificate request.
- **-newkey rsa:4096**: Creates a new private key using the RSA algorithm with a 4096-bit key length.
- **-sha256**: Uses the SHA-256 hashing algorithm to sign the certificate.
- **-days 3650**: Specifies the validity period of the certificate in days, in this case, 3650 days (approximately 10 years).
- **-keyout modalCA.key**: Specifies the file name of the private key to be generated (in this case, "modalCA.key").
- **-out modalCA.crt**: Specifies the file name of the self-signed certificate to be generated (in this case, "modalCA.crt").
___

</div></details>

The "modalCA.key" file contains the CA’s private key, while the "modalCA.crt" file contains the public-key certificate.

To view the decoded content of the X509 certificate and the RSA key, we use the following commands:

```bash
openssl x509 -in modalCA.crt -text -noout
openssl rsa -in modalCA.key -text -noout
```

where:
- **-text**: means decoding the content into plain text
- **-noout**: means not printing out the encoded version

From the output of the commands above, we can observe the following:
- The digital certificate belongs to a CA because `CA:TRUE` is set under the extensinons component.
  **image**
- The digital certificate is a self-signed certificate
  **image**
- The digital certificate contains the modulus and the public exponent
  **image**
  **image**
- The private key contains the following:
  - a public exponent (e)
  - a private exponent (d)
  - a modulus (n)
  - two secret numbers p and q, such that n = pq. 


<br>

### Generating a Certificate Request for Your Web Server

This lab section involves requesting an X509 certificate from our CA.

A company called ukadike32 wants to get a public key certificate from our CA for its webserver, `www.ukadike32.com`. The first step is to generate a Certificate Signing Request (CSR), which basically includes the company's public key and identity information. The CSR will be sent to the CA, who will verify the identity information in the request and then generate a certificate.

Many websites have different URLs that point to the same web server. Due to the hostname matching policy enforced by browsers, the common name in a certificate must match the server’s hostname, or browsers will refuse to communicate with the server.

Using the Subject Alternative Name (SAN) extension, it is possible to specify several hostnames in the subjectAltName field of a certificate. The subjectAltName extension field must also include the hostname from the common name field; otherwise, the common name will not be accepted as a valid name.

Our CSR for `www.ukadike32.com` will include two alternative names.

```bash
openssl req -newkey rsa:2048 -sha256 -keyout ukadike32.key -out ukadike32.csr \
-addext "subjectAltName = DNS:www.ukadike32.com, \
DNS:www.ukadike32A.com, DNS:www.ukadike32B.com"
```

The "server.key" file contains ukadike32's private key, while the "ukadike32.csr" file contains the CSR.

To view the decoded content of the X509 certificate and the RSA key, we use the following commands:

```bash
openssl req -in ukadike32.csr -text -noout
openssl rsa -in ukadike32.key -text -noout
```

**image**


<br>

### Generating a Certificate for your server

This lab section involves issuing an X509 certificate from our CA for an entity.

The CSR file needs to contain the CA’s signature to become a certificate. The CA uses its digital certificate and private key to sign the CSR. This is done through the following command:

<details>
<summary><b>Lab Environment</b></summary>
<div markdown="1">

___
In the below command, modalCA openssl.cnf is the configuration file we copied from /usr/lib/ssl/openssl.cnf and made changes to. For the purpose of this lab, we use the following:
- We use the policy_anything policy defined in the configuration file to bypass the restrictions placed by the default policy. This policy does not enforce any matching rule in the subject name of the CSR and the X509 certificate.
- set "copy_extensions = copy" in the config file. For security reasons, the default setting in openssl.cnf does not allow the "openssl ca" command to copy the extension field from the request to the final certificate.
___

</div></details>

```bash
openssl ca -config modalCA_openssl.cnf -policy policy_anything \
-md sha256 -days 3650 \
-in ukadike32.csr -out ukadike32.crt -batch \
-cert modalCA.crt -keyfile modalCA.key
```

After signing the certificate, we can print out the decoded content of the certificate to check whether the alternative names are included.

```bash
openssl x509 -in ukadike32.crt -text -noout
```

**image**

**image**


<br>

### Deploying Certificate in an Apache-Based HTTPS Website

This lab section involves exploring how public-key certificates are used by websites to secure web browsing. The HTTPS website will be set up on an Apache server.

To create an HTTPS website, we have to tell the Apache server where to get the private key and certificates.

An Apache server has at least a VirtualHost file located in the /etc/apache2/sites-available directory. To serve `ukadike32.com`, we will have to create a VirtualHost file for the site. The VirtualHost file will be named ukadike32_apache_ssl.conf and will contain the following entry:

```apache
<VirtualHost *:443>
  DocumentRoot /var/www/ukadike32
  ServerName www.ukadike32.com
  ServerAlias www.ukadike32A.com
  ServerAlias www.ukadike32B.com
  DirectoryIndex index.html
  SSLEngine On
  SSLCertificateFile /certs/ukadike32.crt
  SSLCertificateKeyFile /certs/ukadike32.key
</VirtualHost>

<VirtualHost *:80>
  DocumentRoot /var/www/ukadike32
  ServerName www.ukadike32.com
  DirectoryIndex index_red.html
</VirtualHost>
```

We also need to enable Apache’s ssl module and then enable the ukadike32 site with the following commands:

```bash
a2enmod ssl
a2ensite ukadike32_apache_ssl
```

Finally, we can start the Apache server and provide the password to unlock ukadike32 site's private key when prompted.

```bash
service apache2 start
```

If the service is already running, we can always restart it using:

```bash
service apache2 restart
```

or reload the configuration files using:

```
service apache2 reload
```

Once everything is set up properly, we can browse the https website. Before we do that, we have to include the site and it's aliases in our host file.

On opening `https://www.ukadike32.com/` we are greated with a warining from firefox browser about a potential security risk. This basically tells us that the CA that issued the certificate for `www.ukadike32.com` is unknown to Firefox and is not to be trusted.

**image**

This can be fixed by importing the modalCA.crt certificate into Firefox. This will add ModalCA to the list of root CAs that Firefox trusts and is aware of. It can be done through the following steps:
- Go to `about:preferences#privacy` and scroll till you find certificates
- Click on view certificates to open the certificate manager window
- Go to the authorities tab and click import to add modalCA.crt to the list of CAs that Firefox trusts.

**image**

**image**

Now, when we revisit `https://www.ukadike32.com/`, the error is gone and the website opens correctly.

**image**

However, Firefox still gives the user a heads up that the certificate issuer is not on it's list of trusted CAs, meaning it did not ship with the software and was added manually.

**image**


<br>

###  Launching a Man-In-The-Middle Attack

In this task, we will show how PKI can defeat Man-In-The-Middle (MITM) attacks. Figure 1 depicts how
MITM attacks work. Assume Alice wants to visit example.com via the HTTPS protocol. She needs to get
the public key from the example.com server; Alice will generate a secret, and encrypt the secret using the
server’s public key, and send it to the server. If an attacker can intercept the communication between Alice
and the server, the attacker can replace the server’s public key with its own public key. Therefore, Alice’s
secret is actually encrypted with the attacker’s public key, so the attacker will be able to read the secret. The
attacker can forward the secret to the server using the server’s public key. The secret is used to encrypt the
communication between Alice and server, so the attacker can decrypt the encrypted communication.
The goal of this task is to help students understand how PKI can defeat such MITM attacks. In the task,
we will emulate an MITM attack, and see how exactly PKI can defeat it. We will select a target website
first. In this document, we use www.example.com as the target website, but in the task, to make it more
meaningful, students should pick a popular website, such as a banking site and social network site











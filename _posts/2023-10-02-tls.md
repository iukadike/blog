---
layout: post
title: Transport Layer Security
excerpt: Transport Layer Security (TLS) is a protocol that enables secure communication between two devices over a network by encrypting the data exchanged between these devices. When a device wants to establish a secure connection with another device, it starts a TLS handshake. Once the TLS handshake is completed and the secure connection is established, the devices can safely exchange data without worrying that someone else might be able to read or modify it.
categories: [crypto, tls, wireshark]
---

Transport Layer Security (TLS) is a protocol that enables secure communication between two devices over a network by encrypting the data exchanged between these devices. When a device wants to establish a secure connection with another device, it starts a TLS handshake. Once the TLS handshake is completed and the secure connection is established, the devices can safely exchange data without worrying that someone else might be able to read or modify it.

The TLS session typically comprises of the following:
- The client initiates the TLS handshake by sending a ClientHello message.
- The server responds with a ServerHello message, selecting the preferred cipher suite and sharing its certificate (if required).
- The client validates the server's certificate and generates a pre-master secret, which is encrypted using the server's public key and sent to the server.
- The server decrypts the pre-master secret, and both the client and server derive the master secret using the pre-master secret and other random values.
- The client and server exchange messages to verify their ability to encrypt and decrypt using the agreed-upon cryptographic parameters.
- If successful, both parties send a Finished message containing a hash and MAC of the entire handshake, confirming that the handshake has been completed securely.

In this post, I aim to document my findings and observations while performing a SEED Lab.

#### Lab Environment

```
client: 10.9.0.5
server: 10.9.0.43
proxy:  10.9.0.143
```


<br>

### TLS Client

In this section of the lab, I incrementally build a simple TLS client program using Python. The aim of this lab is to understand the essential elements and security considerations in TLS programming.

#### TLS handshake

Before a client and a server can communicate securely, both have to agree on several cryptographic parameters. The TLS Handshake Protocol is responsible for this.

The following Python code initiates a TLS handshake with a TLS server:

```python
#!/usr/bin/env python3

import socket
import ssl
import sys
import pprint

hostname = sys.argv[1]
port = 443
cadir = '/etc/ssl/certs'

# Set up the TLS context
context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
context.load_verify_locations(capath=cadir)
context.verify_mode = ssl.CERT_REQUIRED
context.check_hostname = True

# Create the TCP connection
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((hostname, port))
input("After making TCP connection. Press any key to continue ...")

# Add the TLS
ssock = context.wrap_socket(sock, server_hostname=hostname, do_handshake_on_connect=False)
ssock.do_handshake()
print(f"=== Cipher used: { ssock.cipher() }")
print(f"=== Server hostname: { ssock.server_hostname }")
print("=== Server certificate:")
pprint.pprint(ssock.getpeercert())
pprint.pprint(context.get_ca_certs())
input("After TLS handshake. Press any key to continue ...")

# Close the TLS Connection
ssock.shutdown(socket.SHUT_RDWR)
ssock.close()
```

<details>
<summary><b>Code Explanation</b></summary>
<div markdown="1">

___

```python
context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)    #1
context.load_verify_locations(capath=cadir)          #2
context.verify_mode = ssl.CERT_REQUIRED              #3
context.check_hostname = True                        #4
```

- while creating the TLS context, I specify `ssl.PROTOCOL_TLS_CLIENT`. This specifies that a valid cert chain and a hostname are required for the TLS connection to be successful. #1
- line #2 specifies a location that contains the CA certificates to trust for certificate verification.
- line #3 specifies that certificates are required from the other side of the socket connection; in this case, from the server.
- line #4 specifies that the certificate hostname must match the host we are visiting.

___

```python
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)              `#1
sock.connect((hostname, port))                                        `#2
input("After making TCP connection. Press any key to continue ...")    #3
```

- line #1 creates an IPv4 socket object
- line #2 creates a socket connection
- line #3 pauses the program flow, waiting for input from the user

___

```python
ssock = context.wrap_socket(sock, server_hostname=hostname, do_handshake_on_connect=False)    #1
ssock.do_handshake()                                                                          #2
print(f"=== Cipher used: { ssock.cipher() }")                                                 #3
print(f"=== Server hostname: { ssock.server_hostname }")                                      #4
print("=== Server certificate:")                                                              #5
pprint.pprint(ssock.getpeercert())                                                            #6
pprint.pprint(context.get_ca_certs())                                                         #7
input("After TLS handshake. Press any key to continue ...")                                   #8
```

- line #1 uses the TLS context I created earlier to wrap the socket object. The default behavior is to automatically initiate a TLS handshake, but I have chosen not to do so automatically.
- line #2 initiates the TLS handshake
- lines #3 to line #7 print out information about the TLS session
- line #8 pauses the program flow, waiting for input from the user

___

```python
ssock.shutdown(socket.SHUT_RDWR)    #1
ssock.close()                       #2
```

- line #1 shuts down both sides of the TLS connection. SHUT_RDWR indicates that further sends and receives are disallowed.
- line #2 closes TLS object

</div></details>

**image**

Using Wireshark to capture the network traffic during the execution of the program, the following are observed:
- When the program is run, it starts with the 3-way TCP handshake. The code snippet that is responsible for this is `sock.connect((hostname, port))`.

  **image**

- After establishing the TCP connection, it goes on to do a TLS handshake. The code snippet that is responsible for this is `ssock.do_handshake()`.

  **image**

- Finally, the program closes the connections by setting the `FIN` flag on the packets exchanged. The code snippets responsible for this are `ssock.shutdown(socket.SHUT_RDWR)` and `ssock.close()`.

  **image**

In summary, the TCP handshake is the initial step that establishes a network-level connection between the client and server. Once the TCP handshake completes successfully, we can be sure of a reliable, bidirectional communication channel between the client and server. However, the TLS handshake occurs within the established TCP connection. Its purpose is to establish a secure communication channel. It is initiated by the client, which sends a ClientHello message. Once the TLS handshake is completed successfully, every communication between the server and client is encrypted.


#### CA’s Certificate

Instead of making use of the certificates in the `/etc/ssl/certs folder` to verify the server’s certificates, this task makes use of a custom folder.

I proceeded to create a custom folder called "client-certs" and changed the following code snippet:

```python
#cadir = '/etc/ssl/certs'
cadir = './client-certs'
```

On Running the client program, I observed that the execution failed because the program could not find the CA certificate for the host I wanted to connect to.

**image**

To remedy this, I need to get the CA certificate that is needed to verify the `www.google.com` server's certificate and place it in the custom folder. 

<details>
<summary><b>Note</b></summary>
<div markdown="1">
  
When TLS tries to verify a server certificate, it will generate a hash value from the issuer’s identity information, use this hash value as part of the file name, and then use this name to find the issuer’s certificate in the specified folder.

We can create a symbolic link named the hash value that points to the actual CA certificate. First we generate the subject hash of the certificate.

```bash
openssl x509 -in CA.crt -noout -subject_hash
```
Assuming this gives a value of "4a6481c9", we go on to create a symbolic link

```bash
ln -s CA.crt 4a6481c9.0
```

</div></details>

After placing the CA's certificate in the custom location, the program executes successfully.

**image**


#### Experiment with the hostname check

This task helps students understand the importance of hostname checks on the client side.

__Step 1__:
Get the IP address of `www.google.com` using the dig command

```bash
dig www.example.com
```

**image**

__Step 2__:
Modify the /etc/hosts file of the client machine and add the IP address obtained from the dig command.

**image**

__Step 3__:
Switch the following line in the client program between True and False, and then run the client program to www.google2023.com.

```python
context.check_hostname = False
```

The following is observed after running the client program:
- When `context.check_hostname = False`, the program executes successfully. This means that a TLS handshake was complete even though the certificate was never issued to `www.google2023.com`. This means an MITM attack with a valid certificate will not be detected by my program.

  **image**

- When `context.check_hostname = True`, the program doesn't execute successfully. This means that the TLS handshake was interrupted. The program tells us that there was a hostname mismatch. Thus the program was able to detect that though the certificate is valid, it was not issued to `www.google2023.com`. This helps protect against an MITM attack with a valid certificate.

  **image**


#### Sending and getting Data

After establishing a TLS connection with the server, I will send data to it and get its response. Since the server I am communicating with is a HTTPS server, I need to send HTTP requests to it.

The following code sends an HTTP request to `www.google.com` to request its index page, and displays the response received from the server.

```python
#!/usr/bin/env python3

import socket
import ssl
import sys
import pprint

hostname = sys.argv[1]
port = 443
cadir = '/etc/ssl/certs'

# Set up the TLS context
context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
context.load_verify_locations(capath=cadir)
context.verify_mode = ssl.CERT_REQUIRED
context.check_hostname = True

# Create TCP connection
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((hostname, port))

# Add the TLS
ssock = context.wrap_socket(sock, server_hostname=hostname, do_handshake_on_connect=False)
ssock.do_handshake()

# Send HTTP Request to Server
request = b"GET / HTTP/1.0\r\nHost: " + \
    hostname.encode('utf-8') + \
    b"\r\n\r\n"
ssock.sendall(request)
    
# Read HTTP Response from Server
response = ssock.recv(2048)
while response:
    pprint.pprint(response.split(b"\r\n"))
    response = ssock.recv(2048)

# Close the TLS Connection
ssock.shutdown(socket.SHUT_RDWR)
ssock.close()
```

As a result, the server responds with the homepage of `www.google.com` as seen below

**image**

The following code fetches an image file from `i.imgur.com`

```python
#!/usr/bin/env python3

import socket
import ssl
import sys
import pprint

hostname = sys.argv[1]
port = 443
cadir = '/etc/ssl/certs'

# Set up the TLS context
context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
context.load_verify_locations(capath=cadir)
context.verify_mode = ssl.CERT_REQUIRED
context.check_hostname = True

# Create TCP connection
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((hostname, port))

# Add the TLS
ssock = context.wrap_socket(sock, server_hostname=hostname, do_handshake_on_connect=False)
ssock.do_handshake()

# Send HTTP Request to Server
request = b"GET /C8VxEzh.jpeg HTTP/1.0\r\nHost: " + \
    hostname.encode('utf-8') + \
    b"\r\n\r\n"
ssock.sendall(request)
    
# Read HTTP Response from Server
response = ssock.recv(2048)
while response:
    pprint.pprint(response.split(b"\r\n"))
    response = ssock.recv(2048)

# Close the TLS Connection
ssock.shutdown(socket.SHUT_RDWR)
ssock.close()
```

As a result, the server responds with the requested image as seen below

**image**


<br>

### TLS Server

This task involves ...

__prerequisites__:
- create a CA public certificate (ca.crt) and private key (ca.key)
- use the CA's private key to create a server certificate.


#### Create a CA

```bash
openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -keyout ca.key -out ca.crt
```


#### Generate Certificate Signing Request for the Server

```bash
openssl req -newkey rsa:2048 -sha256 -keyout server.key -out server.csr
```


#### Use CA's credentials to Create a Certificate for the Server

```bash
mkdir -p demoCA/newcerts
touch demoCA/indext.txt
echo -n 10 > demoCA/serial
openssl ca -md sha256 -days 3650 -in server.csr -out server.crt -batch -cert ca.crt -keyfile ca.key -policy policy_anything
```


#### Implementing a Simple TLS Server

The following Python code creates a TLS server:

```python
#!/usr/bin/env python3

import socket
import ssl
import pprint

html = \
"""
HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n
<!DOCTYPE html>
<html>
<body>
<h1>Welcome to Ukadike2023.seedlabs!</h1>
</body>
</html>
"""

SERVER_CERT    = './server-certs/server.crt'
SERVER_PRVTKEY = './server-certs/server.key'

context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain(SERVER_CERT, SERVER_PRVTKEY)

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
sock.bind(('0.0.0.0', 4433))
sock.listen(5)

while True:
    newsock, fromaddr = sock.accept()
    try:
        ssock = context.wrap_socket(newsock, server_side=True)  # Establish TLS connection
        print("TLS connection established")
        data = ssock.recv(1024)              # Read data over TLS
        pprint.pprint("Request: {data}")
        ssock.sendall(html.encode('utf-8'))  # Send data over TLS

        ssock.shutdown(socket.SHUT_RDWR)     # Close the TLS connection
        ssock.close()

    except Exception:
        print("TLS connection fails")
        continue
```

<details>
<summary><b>Code Explanation</b></summary>
<div markdown="1">

___

```python
html = \
"""
HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n
<!DOCTYPE html>
<html>
<body>
<h1>Welcome to Ukadike2023.seedlabs!</h1>
</body>
</html>
"""
```

This section of the code contains the HTLM that the server serves to clients.

___

```python
SERVER_CERT    = './server-certs/server.crt'  #1
SERVER_PRVTKEY = './server-certs/server.key'  #2
```

- line #1 specifies the server's public certificate
- line #2 specifies the server's private keys

```python
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)  #1
sock.bind(('0.0.0.0', 4433))                                 #2
sock.listen(5)                                               #3
```

- line #1 creates an IPv4 TCP socket object
- line #2 binds the socket object to the IP address "any" and TCP port 4433
- line #3 instructs the socket object to listen for incoming connections (with up to 5 connections waiting in the queue)

</div></details>

To test the server program, I will use the client program I previously developed. Since the CA for this task is created by me, I will have to add it to a custom folder and direct the client program to search the custom directory.

```bash
openssl x509 -in ca.crt -noout -subject_hash
ln -s ca.crt d7aed4be.0
```

Next, I will put `ukadike2023.seedlabs` in the client's host file and map it to the server's IP address. After making a connection to the server from the client program, the program connects successfully.

**image**


#### Testing the Server Program Using Web Browsers

When visiting `ukadike2023.seedlabs` from the Firefox browser I get a warning that there is a potential risk ahead as the CA who issued the certificate that `ukadike2023.seedlabs` is using is unknown to Firefox. This is rightfully so because the CA was created in the lab and the browser does not have it on its trusted certificate list.

**image**

To remedy this, I need to manually add the created CA’s certificate to Firefox. Once I do that and revisit `ukadike2023.seedlabs`, I do not get any warning from the browser as it now recognizes the CA and the webpage opens.

**image**


#### Certificate with multiple names

Many websites have different URLs. For example, www.example.com, www.example.org, example.
com all point to the same web server. Due to the hostname matching policy enforced by most TLS client
programs, the common name in a certificate must match with the server’s hostname, or TLS clients will
refuse to communicate with the server.
To allow a certificate to have multiple names, the X.509 specification defines extensions to be attached
to a certificate. This extension is called Subject Alternative Name (SAN). Using the SAN extension, it’s
possible to specify several hostnames in the subjectAltName field of a certificate.
To generate a certificate signing request with such a field, we can use a configuration file, and put
all the necessary information in this file (the PKI lab shows how you can do everything in the command
line). The following configuration file gives an example. It specifies the content for the subject field and
add a subjectAltName field in the extension. The field specifies several alternative names, including
a wildcard name *.bank32.com. It should be noted that the field must also include the one from the
common name field; otherwise, the common name will not be accepted as a valid name.






  




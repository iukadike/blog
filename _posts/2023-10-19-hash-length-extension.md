---
layout: post
title: Hash Length Extension Attack
excerpt: When a client and a server communicate over the internet, they are subject to MITM attacks, thus the server needs to verify the integrity of the request received. The standard way to verify the integrity of the request is to attach a tag called MAC to the request. MAC stands for Message Authentication Code. It is a cryptographic method used to verify the integrity and authenticity of a message. A MAC is generated by applying a cryptographic algorithm to the message and a secret key.
categories: [crypto, mac]
---

When a client and a server communicate over the internet, they are subject to MITM attacks, thus the server needs to verify the integrity of the request received. The standard way to verify the integrity of the request is to attach a tag called MAC to the request.

MAC stands for Message Authentication Code. It is a cryptographic method used to verify the integrity and authenticity of a message. A MAC is generated by applying a cryptographic algorithm to the message and a secret key.

A naive way to calculate MAC is to concatenate the key with the message and calculate the one-way hash of the resulting string. This method is subject to the length extension attack, which allows attackers to modify the message while still being able to generate a valid MAC based on the modified message, without knowing the secret
key.

<details>
<summary><b>SeedLabs: Hash Length Extension Attack Lab</b></summary>
<div markdown="1">

- [Hash Length Extension Attack Lab](https://seedsecuritylabs.org/Labs_20.04/Files/Crypto_Hash_Length_Ext/Crypto_Hash_Length_Ext.pdf)

___
</div></details>


<br>

###  Send Request to List Files

This task involves sending a benign request to the server to see how the server responds to the request.

Within the supplied key.txt file is a list of UIDs with corresponding keys. The one I have decided to use for this task is "1005:xciujk"

#### List files on the server

The MAC is calculated by concatenating the key with the contents of the requests -> "xciujk:myname=IfeanyiUkadike&uid=1005&lstcmd=1"

```bash
echo -n "xciujk:myname=IfeanyiUkadike&uid=1005&lstcmd=1" | sha256sum
```

The request to send to list the files on the server is as follows:

```html
http://www.seedlab-hashlen.com/?myname=IfeanyiUkadike&uid=1005&lstcmd=1&mac=d7b362c568eb7ec56b0a6f748c602610038e44cd9e3034f59d95ddcb40b61e3a
```

**image**

#### Download a file from the server

The MAC is calculated by concatenating the key with the contents of the requests -> "xciujk:myname=IfeanyiUkadike&uid=1005&lstcmd=1&download=secret.txt"

```bash
echo -n "xciujk:myname=IfeanyiUkadike&uid=1005&lstcmd=1&download=secret.txt" | sha256sum
```

The request to send to download a file from the server is as follows:

```html
www.seedlab-hashlen.com/?myname=IfeanyiUkadike&uid=1005&myname=IfeanyiUkadike&uid=1005&lstcmd=1&download=secret.txt&mac=ab0424810a8d1dac9cca1a6190b4458cb96dee8f0b12728fe0e9b84c2c1f98ee
```

**image**


<br>

###  Create Padding

To conduct the hash length extension attack, it is vital to understand how padding is calculated for a one-way hash. The block size of SHA-256 is 64 bytes, so a message, "M", will be padded to the multiple of 64 bytes during the hash calculation.

According to RFC 6234, paddings for SHA256 consist of the following:
- one byte of \x80
- followed by many \x00's
- followed by a 64-bit (8 bytes) length field. The length field contains the number of bits in the message. The length field uses the Big-Endian byte order

This task deals with constructing the padding for the following message: "xciujk:myname=IfeanyiUkadike&uid=1005&lstcmd=1" and also encoding all the hexadecimal numbers in the padding by changing "\x" to "%".

I wrote a program in Python to solve the task.

```python
#!/usr/bin/env python3

BLOCKSIZE = 64

#M = "This is a test message"
M = "xciujk:myname=IfeanyiUkadike&uid=1005&lstcmd=1"

padding = 64 - len(M) % 64

lenM_bits = len(M) * 8

def main():
    # the padding structure
    intro = (0x80).to_bytes(1, 'big')
    zero_paddings = (0x00).to_bytes(1, 'big') * (padding - 9)
    length_field = (lenM_bits).to_bytes(8, 'big')
    
    # print the original message
    print(f"\"{M}\"")
    
    # print out the intro
    print_intro(intro)
    
    # print out the zero paddings
    print_zero_paddings(zero_paddings) 
    print()
    
    # print out the length field
    print_length_field(length_field)   
    print()
    
    # print out full padding
    print("padding = ", end="")
    print_full_padding(intro, zero_paddings, length_field)
    print()
    
    # print out the padding encoded
    print("padding encoded = ", end="")
    print_encoded_padding(intro, zero_paddings, length_field)
    print()
    
def print_intro(intro):
    for _ in intro:
        print(f"\"\\x{_:02x}\"")
        
def print_zero_paddings(zero_paddings):
    x = 0
    print_apostrophe()
    for _ in zero_paddings:
        print(f"\\x{_:02x}", end="")
        x += 1
        if x % 10 == 0:
            print()
    print_apostrophe()
        
def print_length_field(length_field):
    print_apostrophe()
    for _ in length_field:
        print(f"\\x{_:02x}", end="")
    print_apostrophe()

def print_full_padding(intro, zero_paddings, length_field):
    full_pad = intro + zero_paddings + length_field
    print_apostrophe()
    for _ in full_pad:
        print(f"\\x{_:02x}", end="")
    print_apostrophe()
        
def print_encoded_padding(intro, zero_paddings, length_field):
    full_pad = intro + zero_paddings + length_field
    print_apostrophe()
    print(''.join(f'%{_:02x}' for _ in full_pad), end="") 
    print_apostrophe()
    
def print_apostrophe():
    print("\"", end="")    


if __name__ == '__main__':
    main()
```

**image**


<br>

### The Length Extension Attack

This task involves generating a valid MAC for a URL without knowing the MAC key.

Assume that we know the MAC of a valid request R, and we also know the size of the MAC key. Our job is to forge a new request based on R, while still being able to compute the valid MAC.

Given the original message M="This is a test message" and its MAC value, we will show how to add a message "Extra message" to the end of the padded M, and then compute its MAC, without knowing the secret MAC key.

---
layout: post
title: Pseudo Random Number Generation
excerpt: A pseudo-random number is a number that appears to be random but is generated using algorithms. These algorithms use a starting value called a seed and perform mathematical operations on it to produce a sequence of seemingly random numbers. Pseudo-random number generators (PRNGs) are widely used in computer science and simulations to mimic random behavior. Though efficient, it is important to remember that pseudo-random numbers are predictable because you always get the same value when you use the same seed value and algorithm.
categories: [crypto, prng]
---

A pseudo-random number is a number that appears to be random but is generated using algorithms. These algorithms use a starting value called a seed and perform mathematical operations on it to produce a sequence of seemingly random numbers. Pseudo-random number generators (PRNGs) are widely used in computer science and simulations to mimic random behavior. Though efficient, it is important to remember that pseudo-random numbers are predictable because you always get the same value when you use the same seed value and algorithm.

It's important to note that pseudo-random numbers should not be used for tasks that require true randomness, such as cryptographic purposes, as they can be potentially exploited by attackers who can predict the sequence based on the algorithm and seed used.

<details>
<summary><b>SeedLabs: Pseudo Random Number Generation Lab</b></summary>
<div markdown="1">

- [MD5 Collision Attack Lab](https://seedsecuritylabs.org/Labs_20.04/Files/Crypto_Random_Number/Crypto_Random_Number.pdf)

___
</div></details>


<br>

### Generate Encryption Key in a Wrong Way

To generate good pseudo-random numbers, we need to start with something that is random; otherwise, the outcome will be quite predictable. The below program uses the current time (epoch time) as a seed for the pseudo-random number generator.

```c
```

After compiling the code and running the program, I observed the following:
- Each time I run the program, the seed that is used (epoch time) differs.
- Each time I run the program, the pseudo-random number that is generated is significantly different.

**image**

However, when I comment out `srand(time(NULL))`, I observed the following:
- Each time I run the program, the same seed is used because I do not provide a seed via `srand()`. This becomes equivalent to using `srand(0)
- Each time I run the program, the pseudo-random number that is generated is the same; it never changes.

**image**

After creating and running a number of additional tests, I can conclude that:
- every time rand() is called in a running program/session, it will produce the same output for the same number of iterations.
- to determine the seed that rand() uses when creating pseudo-random numbers, I can make use of srand() to set the seed.
- srand() has to be set exactly once outside of the loop, else it will always keep initializing.
- time() is used as the seed provided to `srand()` because every time the program is run, epoch time will be different. This ensures that the value used during `srand()` initializations is always different.


<br>

### Guessing the Key

Task Background:

On April 17, 2018, Alice finished her tax return, and she saved the return (a PDF file) on her disk. To protect the file, she encrypted the PDF file using a key generated from the program in the previous task 1. She wrote down the key in a notebook, which is securely stored in a safe. A few months later, Bob broke into her computer and got a copy of the encrypted tax return. Since Alice is the CEO of a big company, this file is very valuable.

Bob cannot get the encryption key, but by looking around Alice’s computer, he sees the key-generation program and suspects that Alice’s encryption key may be generated by the program. He also noticed the timestamp of the encrypted file, which is "2018-04-17 23:08:49". He guessed that the key may be generated within a two-hour window before the file was created.

Since the file is a PDF file, which has a header. The beginning part of the header is always the version number. Around the time when the file was created, PDF-1.5 was the most common version, i.e., the header starts with "%PDF-1.5", which is 8 bytes of data. The next 8 bytes of the data are quite easy to predict as well. Therefore, Bob easily got the first 16 bytes of the plaintext. Based on the metadata of the encrypted file, he knows that the file is encrypted using aes-128-cbc. Since AES is a 128-bit cipher, the 16-byte plaintext consists of one block of plaintext, so Bob knows a block of plaintext and its matching ciphertext.

Moreover, Bob also knows the Initial Vector (IV) from the encrypted file (IV is never encrypted). Thus Bob knows the following:

```
Plaintext:  255044462d312e350a25d0d4c5d80a34
Ciphertext: d06bf9d0dab8e8ef880660d2af65aa82
IV:         09080706050403020100A2B2C2D2E2F2
```

The purpose of this task is to help Bob find Alice’s encryption key (by writing a program to try all the possible keys), so you I decrypt the entire document. If the key was generated correctly, this task will not be possible. However, since Alice used time() to seed her random number generator, I should be able to find out her key easily.

You can use the date command to print out the number of seconds between a
specified time and the Epoch, 1970-01-01 00:00:00 +0000 (UTC). See the following example
`$ date -d "2018-04-15 15:00:00" +%s`
